# Task ID: 3
# Title: Implement Real-Time WebSocket Streaming for Exchange Adapters
# Status: done
# Dependencies: 1, 2
# Priority: high
# Description: Replace the inefficient HTTP polling mechanism with a true WebSocket implementation to receive real-time market data. This task requires two fundamentally different integration strategies based on research findings: 1) **Unified Library Approach:** Utilize `ccxt.pro` for the Binance adapter, offering low implementation effort and easy maintenance. 2) **Native API Approach:** Implement bespoke, high-effort integrations for Futu and Interactive Brokers using their native SDKs to achieve complete feature access and optimal performance.
# Details:
1. **Dependency Integration:**
   - Add the `ccxt.pro` library to the project's dependencies. This will be the primary tool for exchanges it supports, such as Binance.

2. **Architectural Refactoring:**
   - Modify the `foxtrot.gateway.BaseAdapter` or create a new `StreamingBaseAdapter` to support persistent, asynchronous WebSocket connections.
   - The adapter interface must include methods for `connect()`, `disconnect()`, `subscribe(symbol)`, and `unsubscribe(symbol)`.
   - The adapter must manage the WebSocket connection in a non-blocking manner (e.g., using asyncio in Python or a separate thread) to avoid halting the `MainEngine`.

3. **Unified Library Path (Binance):**
   - Update the existing `BinanceAdapter` to utilize `ccxt.pro` for streaming data.
   - Implement a long-running task that calls methods like `watch_order_book` or `watch_trades`.
   - On receipt of data, transform it into the standardized `foxtrot` framework event objects and push them to the `EventEngine`.

4. **Native API Path (Futu/IB):**
   - For adapters like Futu and Interactive Brokers (IB), implement streaming clients using their native APIs.
   - This is a more complex task requiring bespoke management of each exchange's specific connection, subscription, and event-handling logic, while still adhering to the common `StreamingBaseAdapter` interface.

5. **Robust Connection Management:**
   - Implement a resilient auto-reconnect mechanism with exponential backoff for all streaming adapters. Note that heartbeat handling and specific reconnect logic will need to be tailored to each exchange's API.
   - Add comprehensive logging for connection status (connecting, connected, disconnected), subscription changes, and errors.

# Test Strategy:
1. **Unit Testing (Mocked Clients):**
   - In `tests/unit/adapter/`, create separate test suites that mock the `ccxt.pro` client (for Binance) and the native WebSocket clients (for Futu, IB).
   - Simulate a full lifecycle of WebSocket events: connection success, data messages, heartbeats, errors, and disconnections.
   - Verify that the adapter correctly parses incoming data payloads and pushes standardized events to a mock `EventEngine`.
   - Test the auto-reconnect logic by simulating a disconnection and asserting that the adapter attempts to reconnect according to the backoff strategy.

2. **Integration Testing (Live Testnet):**
   - Configure tests to connect to exchange testnet/paper-trading environments (e.g., Binance Spot Testnet, IB Paper Trading).
   - Write tests that subscribe to a live data feed, receive at least 10 updates, and then unsubscribe.
   - Verify that the received data is correctly structured and reflects real-time market activity.
   - Test connection resilience by programmatically interrupting the network connection and confirming that the adapter successfully reconnects.

3. **Performance & Latency Benchmarking:**
   - Create a benchmark test to measure the end-to-end latency from message receipt at the socket to event processing in the `EventEngine`.
   - Compare latency metrics against the legacy HTTP polling system to formally validate the performance improvement.
   - Conduct a stress test by subscribing to 20+ different streams simultaneously to monitor CPU, memory, and network usage under load.

# Subtasks:
## 1. Architect and Implement the StreamingBaseAdapter Interface [done]
### Dependencies: None
### Description: Create the foundational asynchronous architecture for WebSocket streaming. This involves defining a new abstract base class with a clear interface for managing persistent connections and data subscriptions, and integrating the `ccxt.pro` dependency in preparation for the first implementation.
### Details:
Create a new `foxtrot.gateway.StreamingBaseAdapter` class. It must define the abstract async methods: `connect()`, `disconnect()`, `subscribe(symbol)`, and `unsubscribe(symbol)`. The design must support non-blocking, asynchronous operations (e.g., using `asyncio`). Add the `ccxt.pro` library to the project's dependencies.
<info added on 2025-08-03T15:16:04.311Z>
Based on a change in approach, the creation of a new `StreamingBaseAdapter` is no longer required. This task will now focus on adapting the existing `foxtrot.gateway.BaseAdapter` framework to support real-time WebSocket streaming. The implementation will use the `ccxt.pro` library to replace the current HTTP polling mechanism with a persistent WebSocket connection, ensuring the change is compatible with the existing `BaseAdapter` interface.
</info added on 2025-08-03T15:16:04.311Z>
<info added on 2025-08-03T15:16:48.334Z>
The task has been updated to reflect a new approach. The new title is "Integrate ccxt.pro and Enhance BaseAdapter for WebSocket Support". The description is now focused on adding the `ccxt.pro` dependency and enhancing the existing `BaseAdapter` implementations to support WebSocket connections, while maintaining the current interface. This is an implementation enhancement, not the creation of a new interface.
</info added on 2025-08-03T15:16:48.334Z>
<info added on 2025-08-03T15:42:49.480Z>
Integrate the `ccxt.pro` library to enhance the existing `foxtrot.gateway.BaseAdapter` with real-time WebSocket streaming capabilities. This task involves adding `ccxt.pro` to the project's dependencies and modifying the adapter's internal logic to use a persistent WebSocket connection instead of the current HTTP polling mechanism. The implementation must maintain the existing `BaseAdapter` interface, ensuring the change is a seamless enhancement rather than the creation of a new streaming-specific interface.
</info added on 2025-08-03T15:42:49.480Z>
<info added on 2025-08-03T15:44:17.989Z>
The title has been updated to "Integrate ccxt.pro and Enhance BaseAdapter for WebSocket Support" and the description has been refined to "Add ccxt.pro dependency and enhance the existing BaseAdapter framework to support WebSocket streaming capabilities while maintaining the current interface". The implementation details have been consolidated to reflect this single, current approach, removing historical notes.
</info added on 2025-08-03T15:44:17.989Z>
<info added on 2025-08-03T16:30:38.421Z>
Based on a comprehensive design analysis using the CCXT.pro manual, the implementation plan has been updated with the following details:

### Key Decision: Maintain BaseAdapter Interface
No breaking changes will be introduced; the WebSocket implementation will be internal to the adapter. This approach preserves backward compatibility with the existing framework.

### Implementation Steps:

1.  **Add ccxt.pro Dependency**
    *   Update `pyproject.toml` to include `ccxt.pro ^4.4.0`.
    *   Retain the standard `ccxt` library to ensure compatibility and provide an HTTP fallback mechanism.

2.  **Enhance BinanceApiClient**
    *   Initialize both `ccxt` and `ccxt.pro` exchange instances within the client.
    *   Introduce a configuration flag to allow runtime selection between WebSocket and HTTP modes.
    *   Implement a factory method for creating the appropriate exchange instance based on the selected mode.

3.  **Create WebSocket Manager**
    *   A new module will be created at `foxtrot/adapter/binance/websocket_manager.py`.
    *   This manager will handle the connection lifecycle, including states for `DISCONNECTED`, `CONNECTING`, and `CONNECTED`.
    *   It will feature an auto-reconnect mechanism with exponential backoff to handle connection drops gracefully.
    *   It will also manage and persist subscription states across reconnections.

4.  **Build Async-Threading Bridge**
    *   A new utility module will be created at `foxtrot/util/websocket_utils.py`.
    *   This module will manage a dedicated `asyncio` event loop running in a separate thread.
    *   It will use `asyncio.run_coroutine_threadsafe()` to safely emit events from the `asyncio` loop to the main application's threading context, ensuring compatibility with the `BaseAdapter`'s existing threading model.

### Test Strategy Enhancement:
*   Mock `ccxt.pro` WebSocket operations to isolate and test adapter logic.
*   Verify the full connection lifecycle, including all state transitions (`CONNECTING`, `CONNECTED`, `DISCONNECTED`, reconnect).
*   Validate the functionality of the async-to-threading bridge to ensure thread-safe communication.
*   Test the configuration flag to confirm seamless switching between WebSocket and HTTP modes.
</info added on 2025-08-03T16:30:38.421Z>
<info added on 2025-08-03T17:22:57.843Z>
The WebSocket infrastructure has been successfully implemented as per the detailed plan. This includes adding the `ccxt.pro` dependency, creating the `AsyncThreadBridge` for asyncio-threading integration, and building the `WebSocketManager` with state management and auto-reconnection logic. The `BinanceApiClient` has been enhanced to support both WebSocket and HTTP modes. All associated unit tests have been implemented and are passing, confirming the stability of the new components.
</info added on 2025-08-03T17:22:57.843Z>

## 2. Implement Binance WebSocket Adapter using the Unified `ccxt.pro` Library [done]
### Dependencies: 3.1
### Description: Implement the 'Unified Library Approach' by refactoring the `BinanceAdapter` to inherit from `StreamingBaseAdapter` and use `ccxt.pro` for real-time data. This serves as the first concrete implementation of the new streaming architecture.
### Details:
The `BinanceAdapter` must implement all methods from `StreamingBaseAdapter`. A long-running `asyncio` task should be created within the adapter to call `ccxt.pro` methods like `watch_order_book`. Upon receiving data, it must be transformed into standardized `foxtrot` event objects and pushed to the `EventEngine`.
<info added on 2025-08-03T15:17:14.513Z>
This implementation will now refactor the existing `BinanceAdapter` to integrate `ccxt.pro`'s WebSocket capabilities while maintaining full compatibility with the `BaseAdapter` interface. Instead of inheriting from the new `StreamingBaseAdapter`, the focus is on replacing the internal HTTP polling logic with a persistent, long-running `asyncio` task that uses `ccxt.pro`'s `watch_*` methods. This ensures the adapter receives real-time data and pushes it to the `EventEngine` without altering its external-facing methods, allowing it to function as a drop-in upgrade within the current system architecture.
</info added on 2025-08-03T15:17:14.513Z>
<info added on 2025-08-03T15:44:51.694Z>
Refactor the existing `BinanceAdapter` to integrate `ccxt.pro`'s WebSocket capabilities, replacing the internal HTTP polling logic. The implementation must maintain full compatibility with the `BaseAdapter` interface, ensuring the adapter functions as a drop-in upgrade.

A persistent, long-running `asyncio` task will be implemented within the adapter. This task will use `ccxt.pro`'s `watch_*` methods to receive real-time data. Upon receipt, the data will be transformed into standardized `foxtrot` event objects and pushed to the `EventEngine`.
</info added on 2025-08-03T15:44:51.694Z>
<info added on 2025-08-03T15:45:18.871Z>
Refactor the BinanceAdapter to use ccxt.pro WebSocket connections while maintaining BaseAdapter interface compatibility for seamless integration.
</info added on 2025-08-03T15:45:18.871Z>
<info added on 2025-08-03T16:31:17.780Z>
## Core WebSocket Implementation for BinanceAdapter

### Key Implementation Strategy:
Replace HTTP polling loop with true WebSocket streaming using ccxt.pro's watch methods.

### Technical Implementation:

1.  **Transform BinanceMarketData._run_websocket()**
    *   FROM: HTTP polling with 1-second sleep
    *   TO: Async WebSocket loop with real-time streaming

2.  **Async WebSocket Loop Architecture**
    ```python
    # Start WebSocket in dedicated asyncio thread
    self.async_bridge.start()
    self.async_bridge.run_async_in_thread(self._async_websocket_loop())
    
    # Main async loop with ccxt.pro integration
    async def _async_websocket_loop(self):
        websocket_manager = WebSocketManager(self.api_client.exchange, self.async_bridge)
        while self._active:
            # Use ccxt.pro watchTicker for real-time updates
            async for ticker in self.api_client.exchange.watchTicker(symbol):
                tick_data = self._convert_ticker_to_tick(ticker, symbol)
                self.async_bridge.emit_event_threadsafe(Event(EVENT_TICK, tick_data))
    ```

3.  **Data Flow Implementation**
    *   WebSocket receives ticker data via ccxt.pro
    *   Convert CCXT format to Foxtrot TickData objects
    *   Thread-safe event emission to EventEngine
    *   Maintain subscription tracking for recovery

4.  **Error Handling Integration**
    *   Network errors trigger auto-reconnect
    *   Symbol-specific errors don't affect other streams
    *   Critical errors fallback to HTTP polling mode

### Performance Targets:
*   Latency: <200ms (vs current 1000ms)
*   Zero data loss during normal operation
*   Seamless reconnection without manual intervention

This implementation maintains full BaseAdapter compatibility while delivering real-time performance.
</info added on 2025-08-03T16:31:17.780Z>
<info added on 2025-08-03T17:07:59.352Z>
Implementation has been successfully completed, fulfilling the requirements for a robust, real-time WebSocket integration while maintaining full backward compatibility.

**Key Components Delivered:**

1.  **`AsyncThreadBridge` (`foxtrot/util/websocket_utils.py`):** A utility to bridge the `asyncio` event loop with the application's threading model, enabling thread-safe operations from the WebSocket thread to the main application.
2.  **`WebSocketManager` (`foxtrot/adapter/binance/websocket_manager.py`):** Manages the WebSocket connection lifecycle, including auto-reconnection with exponential backoff, subscription tracking for state restoration, and connection health monitoring.
3.  **`Enhanced BinanceApiClient` (`foxtrot/adapter/binance/api_client.py`):** Integrates both `ccxt` and `ccxt.pro` instances, allowing for configurable WebSocket usage and graceful fallback to HTTP polling if `ccxt.pro` is unavailable.
4.  **`Transformed BinanceMarketData` (`foxtrot/adapter/binance/market_data.py`):** Refactored to support a dual-mode operation, seamlessly switching between WebSocket streaming (`watchTicker`) and the original HTTP polling loop based on configuration.
5.  **`WebSocketErrorHandler` (`foxtrot/adapter/binance/error_handler.py`):** A dedicated handler that classifies connection errors, implements recovery strategies, and uses a circuit breaker pattern to automatically fall back to HTTP polling during persistent WebSocket failures.

**Core Achievements:**

*   **Full `BaseAdapter` Compatibility:** The adapter remains a drop-in replacement with no breaking changes to its public interface.
*   **Seamless Mode Switching:** WebSocket and HTTP polling modes can be toggled via configuration.
*   **Robustness:** The implementation includes comprehensive error handling, auto-recovery mechanisms, and a circuit breaker for high availability.
*   **Performance:** The system is now ready for performance testing against the <200ms latency target.
</info added on 2025-08-03T17:07:59.352Z>
<info added on 2025-08-03T17:23:20.629Z>
Completed BinanceAdapter WebSocket implementation:
- Transformed BinanceMarketData to use ccxtpro watchTicker
- Implemented dual-mode operation (WebSocket/HTTP)
- Added comprehensive error handling with circuit breaker
- Maintained full backward compatibility
- All unit tests passing
</info added on 2025-08-03T17:23:20.629Z>

## 4. Implement Generic Auto-Reconnect and Connection Logging [done]
### Dependencies: 3.2, 3.3
### Description: Build a resilient and observable connection management system applicable to all streaming adapters. This involves creating a generic auto-reconnect mechanism with exponential backoff and adding structured logging for all connection lifecycle events.
### Details:
Enhance the `StreamingBaseAdapter` or a helper utility with a generic retry loop for the `connect` method. This loop must implement an exponential backoff delay. Add comprehensive logging for all connection state changes (e.g., CONNECTING, CONNECTED, DISCONNECTED, RECONNECTING) and subscription actions across all implemented adapters.
<info added on 2025-08-03T15:23:40.457Z>
[
  3.2
]
</info added on 2025-08-03T15:23:40.457Z>
<info added on 2025-08-03T15:46:09.168Z>
Create a generic, reusable auto-reconnect mechanism with exponential backoff and a structured logging system. This component will be used by all streaming adapters to ensure connection resilience and observability.

**Key Requirements:**

1.  **Auto-Reconnect Utility:** Implement a generic wrapper or helper that manages the connection lifecycle, automatically attempting to reconnect upon disconnection.
2.  **Exponential Backoff:** The reconnect logic must use an exponential backoff delay between retries to avoid overwhelming the remote server.
3.  **Structured Logging:** Add comprehensive logging for all critical events:
    *   **Connection States:** `CONNECTING`, `CONNECTED`, `DISCONNECTED`, `RECONNECTING` (including retry attempt and delay).
    *   **Subscription Actions:** `SUBSCRIBING`, `SUBSCRIBED`, `UNSUBSCRIBING`, `UNSUBSCRIBED`.
</info added on 2025-08-03T15:46:09.168Z>
<info added on 2025-08-03T15:46:38.718Z>
Test Strategy:

1.  **Unit Testing the Generic Reconnect Utility (using Binance Adapter):**
    *   Create a dedicated test suite for the generic auto-reconnect and logging utility.
    *   Instantiate the `BinanceAdapter` (from subtask 3.2) and wrap it with the new reconnect utility to serve as the concrete test subject.
    *   **Simulate Connection Failures:** Mock the underlying `ccxt.pro` client's connect method to consistently raise exceptions.
    *   **Verify Exponential Backoff:** Assert that the reconnect utility attempts to reconnect after delays that increase exponentially. Capture timestamps or mock the `asyncio.sleep` function to verify the delay duration for each attempt.
    *   **Verify Logging:** Mock the logging system to capture log records. Assert that structured logs for `DISCONNECTED`, `RECONNECTING` (with retry count and delay), and `CONNECTED` are emitted at the correct stages of the lifecycle.
    *   **Verify Successful Reconnect:** After simulating several failures, allow the mocked connect method to succeed. Assert that the system's state transitions to `CONNECTED` and that the retry loop is terminated.
</info added on 2025-08-03T15:46:38.718Z>
<info added on 2025-08-03T16:31:59.861Z>
**Design Update based on Comprehensive Analysis:**

**Implementation Strategy:**
The generic connection management system will be enhanced based on a more detailed design, potentially within a dedicated `WebSocketManager` class.

**Core Component Enhancements:**
*   **Subscription Restoration:** After a successful reconnection, the system must automatically restore all previously active subscriptions.
*   **Connection Health Monitoring:** Implement a heartbeat mechanism to proactively monitor connection health and detect silent disconnections.
*   **Circuit Breaker Pattern:**
    *   Introduce a circuit breaker to track consecutive connection failures.
    *   After a configurable threshold of failures, the system should automatically fall back to an alternative data source (e.g., HTTP polling).
    *   The system must periodically test for WebSocket recovery before attempting to switch back from the fallback mechanism.
*   **Specific Exponential Backoff Algorithm:**
    *   Use the following parameters: `base_delay = 1.0s`, `max_delay = 60.0s`, `max_attempts = 50`. The delay should be calculated as `min(base_delay * (2 ** attempt), max_delay)`.
*   **Enhanced Logging:** Error logs must include detailed context and a classification of the error type.

**Test Strategy Enhancements:**
*   Add test cases to validate that all subscriptions are correctly restored after a successful reconnection.
*   Create specific tests to verify the circuit breaker's functionality, including its activation on repeated failures and its recovery process.
</info added on 2025-08-03T16:31:59.861Z>

## 5. Comprehensive Testing and Performance Validation [done]
### Dependencies: 3.1, 3.2, 3.4
### Description: Execute a 3-layer testing strategy to validate WebSocket implementation reliability, performance, and production readiness
### Details:
## Testing Strategy Overview

### Layer 1: Unit Testing (95%+ Coverage)
- Mock ccxt.pro WebSocket operations
- Test connection lifecycle and state transitions
- Validate async-to-threading bridge functionality
- Test error scenarios and recovery mechanisms
- Verify data transformation accuracy

### Layer 2: Integration Testing
- Use Binance testnet for real WebSocket validation
- Test end-to-end data flow: WebSocket → EventEngine → MainEngine
- Multi-symbol concurrent subscriptions (10+ symbols)
- Network failure simulation and recovery testing
- 24-hour stability testing

### Layer 3: Performance Benchmarking
**Targets:**
- Average latency: <200ms (vs current 1000ms)
- P95 latency: <500ms
- Memory increase: <50MB per connection
- CPU increase: <20% under normal load
- Connection uptime: >99.5% over 24 hours

**Benchmark Implementation:**
```python
# Latency measurement
async def test_latency_benchmarking():
    latencies = []
    def measure_latency(event):
        latency = time.time() * 1000 - event.data.timestamp
        latencies.append(latency)
    
    # Run for 5 minutes
    await asyncio.sleep(300)
    
    avg_latency = sum(latencies) / len(latencies)
    assert avg_latency < 200
```

### Test Files to Create:
- `tests/unit/adapter/binance/test_websocket_manager.py`
- `tests/unit/adapter/binance/test_market_data_websocket.py`
- `tests/unit/util/test_websocket_utils.py`
- `tests/integration/test_websocket_e2e.py`
- `tests/performance/test_websocket_benchmarks.py`

## 6. Production Deployment with Feature Flags and Monitoring [done]
### Dependencies: 3.5
### Description: Implement feature flags, monitoring, and gradual rollout strategy for safe production deployment
### Details:
## Production Deployment Strategy

### Feature Flag Implementation
Configure WebSocket enablement through settings:
```json
{
    "websocket.enabled": true,
    "websocket.symbols": ["BTCUSDT", "ETHUSDT"],
    "websocket.fallback_on_error": true,
    "websocket.max_reconnect_attempts": 50,
    "websocket.reconnect_base_delay": 1.0
}
```

### Gradual Rollout Phases
1. **Phase 1** (Day 1): Single symbol (BTCUSDT) testing
2. **Phase 2** (Days 2-4): Top 5 liquid symbols
3. **Phase 3** (Week 2): All major symbols
4. **Phase 4** (Week 3): Full production deployment

### Monitoring & Alerting Setup
**Key Metrics:**
- Connection uptime (target: >99%)
- Average latency (alert: >300ms)
- Reconnection rate (alert: >5/hour)
- Error rate (alert: >5%)
- Memory usage (alert: >50MB increase)
- CPU usage (alert: >20% increase)

### Circuit Breaker Configuration
```python
class WebSocketCircuitBreaker:
    def __init__(self):
        self.failure_threshold = 5
        self.recovery_timeout = 60
        self.state = CircuitState.CLOSED
```

### Rollback Triggers
- Error rate >5% over 5 minutes
- Average latency >2x baseline (2000ms)
- Connection stability <95% over 1 hour
- Memory usage increase >100MB
- Manual override capability

### Recovery Procedures
1. Test single symbol recovery
2. Gradual re-enablement (5-minute validation)
3. Expand to top symbols (10-minute validation)
4. Full re-enablement after validation

### Documentation Requirements
- Operations runbook for monitoring
- Rollback procedures guide
- Performance baseline documentation
- Troubleshooting guide

